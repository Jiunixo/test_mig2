"""solver models for Code_TYMPAN
"""

import cython as cy

import numpy as np

from tympan.models cimport common as tycommon
from tympan.core cimport unique_ptr, shared_ptr

cdef class ProblemModel:

    def __cinit__(self):
        self.thisptr = shared_ptr[AcousticProblemModel](new AcousticProblemModel())

    @property
    def npoints(self):
        """ Return the number of mesh nodes contained in the acoustic problem
            model
        """
        assert self.thisptr.get() != NULL
        return self.thisptr.get().npoints()

    @property
    def ntriangles(self):
        """ Return the number of mesh triangles contained in the acoustic problem
            model
        """
        assert self.thisptr.get() != NULL
        return self.thisptr.get().ntriangles()

    @property
    def nmaterials(self):
        """ Return the number of acoustic materials contained in the acoustic
            problem model
        """
        assert self.thisptr.get() != NULL
        return self.thisptr.get().nmaterials()

    @property
    def nsources(self):
        """ Return the number of acoustic sources involved in the acoustic
            problem model
        """
        assert self.thisptr.get() != NULL
        return self.thisptr.get().nsources()

    @property
    def nreceptors(self):
        """ Return the number of acoustic receptors involved in the acoustic
            problem model
        """
        assert self.thisptr.get() != NULL
        return self.thisptr.get().nreceptors()

    def source(self, idx):
        """ Return the acoustic source (SolverSource object) of index 'idx'
        """
        assert self.thisptr.get() != NULL
        source = SolverSource()
        source.thisptr = cy.address(self.thisptr.get().source(idx))
        return source

    @property
    def sources(self):
        """ Return all the acoustic sources of the model
        """
        assert self.thisptr.get() != NULL
        sources = []
        for i in xrange(self.nsources):
            source = SolverSource()
            source.thisptr = cy.address(self.thisptr.get().source(i))
            sources.append(source)
        return sources

    def receptor(self, idx):
        """ Return the acoustic receptor (SolverReceptor object) of index 'idx'
        """
        assert self.thisptr.get() != NULL
        receptor = SolverReceptor()
        receptor.thisptr = cy.address(self.thisptr.get().receptor(idx))
        return receptor

    @property
    def receptors(self):
        """ Return all the acoustic receptors of the model
        """
        assert self.thisptr.get() != NULL
        receptors = []
        for i in xrange(self.nreceptors):
            receptor = SolverReceptor()
            receptor.thisptr = cy.address(self.thisptr.get().receptor(i))
            receptors.append(receptor)
        return receptors

    def export_triangular_mesh(self):
        """ Build a triangular mesh from the acoustic problem model.
            Return two nparrays:
                * 'nodes': an array of nodes (of dimension 'npoints'X3), where
                each line stands for a node and contains 3 coordinates)
                * 'triangles': an array of triangles (of dimension 'ntriangles'X3),
                where each line stands for a triangle and contains the indices of
                its 3 vertices in the 'nodes' array.
        """
        assert self.thisptr.get() != NULL
        nb_elts = cy.declare(cy.uint)
        actri = cy.declare(cy.pointer(AcousticTriangle))
        nb_elts = self.thisptr.get().ntriangles()
        triangles = np.empty([nb_elts, 3], dtype=int)
        for i in xrange(nb_elts):
            actri = cy.address(self.thisptr.get().triangle(i))
            triangles[i] = [actri.n[0], actri.n[1], actri.n[2]]
        point = cy.declare(cy.pointer(tycommon.OPoint3D))
        nb_elts = self.thisptr.get().npoints()
        nodes = np.empty([nb_elts, 3])
        for i in xrange(nb_elts):
            point = cy.address(self.thisptr.get().node(i))
            nodes[i] = [point._x, point._y, point._z]
        return (nodes, triangles)


cdef class ResultModel:
    def __cinit__(self):
        self.thisptr = shared_ptr[AcousticResultModel](new AcousticResultModel())


cdef class Solver:

    @cy.locals(model=ProblemModel)
    @cy.returns((bool, ResultModel))
    def solve_problem(self, model):
        """Solve the acoustic problem by calling the underlying
        SolverInterface::solve() C++ method.

        Raises a RuntimeError in case of computation failure.
        """
        result = ResultModel()
        if not self.thisptr.solve(model.thisptr.get()[0],
                                  result.thisptr.get()[0]):
            raise RuntimeError(
                'Computation failed (C++ SolverInterface::solve() method '
                'returned false)')
        return result

    def purge(self):
        self.thisptr.purge()


cdef class SolverSource:
    thisptr = cy.declare(cy.pointer(AcousticSource))

    def __cinit__(self):
        self.thisptr = NULL

    @property
    def position(self):
        """ Return the acoustic source position (as a 'Point3D' object)
        """
        assert self.thisptr != NULL
        return tycommon.opoint3d2point3d(self.thisptr.position)

    @property
    def spectrum(self):
        """ Return the acoustic spectrum of the Source (dB scale, power spectrum)
        """
        assert self.thisptr != NULL
        return tycommon.ospectre2spectrum(self.thisptr.spectrum)


cdef class SolverReceptor:
    thisptr = cy.declare(cy.pointer(AcousticReceptor))

    def __cinit__(self):
        self.thisptr = NULL

    @property
    def position(self):
        """ Return the acoustic source position (as a 'Point3D' object)
        """
        assert self.thisptr != NULL
        return tycommon.opoint3d2point3d(self.thisptr.position)

