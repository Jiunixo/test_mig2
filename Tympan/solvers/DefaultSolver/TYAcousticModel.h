/*
 * Copyright (C) <2012-2014> <EDF-R&D> <FRANCE>
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#ifndef __TYACOUSTICMODEL__
#define __TYACOUSTICMODEL__

#include "Tympan/core/interfaces.h"
#include "Tympan/solvers/DefaultSolver/TYChemin.h"
#include "Tympan/solvers/DefaultSolver/TYSolverDefines.h"

class TYTrajet;
class TYSolver;

/**
 * \class TYAcousticModel
 * \brief Acoustic model for the default solver
 */
class TYAcousticModel : public AcousticModelInterface
{
public:
    TYAcousticModel(TYSolver& solver); //<! Constructor
    virtual ~TYAcousticModel();	//<! Destructor

    virtual void compute(const std::deque<TYSIntersection>& tabIntersect,
                         TYTrajet& trajet, TabPoint3D& ptsTop, TabPoint3D& ptsLeft,
                         TabPoint3D& ptsRight );

    /// Initialize the acoustic model
    void init();

    /**
     * @brief Compute the segment path from the list of the points of the TYTrajet journey. It takes in account the ground reflection.
     * @param [in] rayon A segment describing the acoustic ray.
     * @param [in] source The acoustic source.
     * @param [in] pts The list of points of the journey.
     * @param [in] vertical boolean to indicate we deal with the vertical plane
     * @param [out] TabChemins Paths list of the journey
     * @param [out] distance Journey distance
     *
     * @return <code>true</code> if succeeds;
     *         <code>false</code> otherwise.
     */
    virtual bool computeCheminsAvecEcran(const OSegment3D& rayon, const tympan::AcousticSource& source,
                                         const TabPoint3D& pts, const bool vertical,
                                         TYTabChemin& TabChemins, double distance ) const;

    /**
     * @brief Compute the list of path generated by reflection on the vertical walls.
     * @param [in] tabIntersect Array of intersections
     * @param [in] rayon A segment describing the acoustic ray.
     * @param [in] source The acoustic source.
     * @param [out] TabChemins Paths list of the journey generated by reflection.
     * @param [out] distance Journey distance
     */
    void computeCheminReflexion(const std::deque<TYSIntersection>& tabIntersect, const OSegment3D& rayon,
                                const tympan::AcousticSource& source, TYTabChemin& TabChemins,
                                double distance ) const;

    // * \fn getSpectreAttVegetation
    // * @brief Calcule les spectres d'attenuation caracteristiques de la vegetation
    // * pour chaque terrain survole par rayon.
    // *
    // * @param rayon Un segment representant le rayon acoustique.
    // * @param tabSegSp Le tableau dans lequel sont stockes les spectres d'attenuation et segments associes.
    // * @param penteMoyenne La pente moyenne sur le rayon.
    // */
    //void getSpectreAttVegetation(const OSegment3D& rayon, const OSegment3D& penteMoyenne, TYTabStructSegLPSp& tabSegSp) const;

    // * \fn computeCheminAvecVeg
    // * @brief Calcule le chemin direct en tenant compte de la vegetation.
    // *
    // * @param rayon Un segment representant le rayon acoustique.
    // * @param Atmo L'atmosphere courante.
    // * @param pSrcGeoNode La source ponctuelle.
    // * @param penteMoyenne La pente moyenne sur le rayon.
    // *
    // * @return Le chemin determine.
    // */
    //void computeCheminAvecVeg(const OSegment3D& rayon, const tympan::AcousticSource& source, const OSegment3D& penteMoyenne, TYTabChemin& TabChemin, double distance) const;

    /**
     * @brief Compute the list of paths generated by reflection on the ground if there is no screen.
     * @param [in] rayon A segment describing the acoustic ray.
     * @param [in] source The acoustic source.
     * @param [out] TabChemins Paths list of the journey generated (1 or 2 under favorables conditions).
     * @param [out] distance Journey distance
     */
    void computeCheminSansEcran(const OSegment3D& rayon, const tympan::AcousticSource& source, TYTabChemin& TabChemins, double distance) const;

    /**
     * @brief Compute the list of paths for a perfectly flat and reflective ground.
     * @param [in] rayon A segment describing the acoustic ray.
     * @param [in] source The acoustic source.
     * @param [out] TabChemins Paths list of the journey generated.
     * @param [out] distance Journey distance
     */
    void computeCheminAPlat(const OSegment3D& rayon, const tympan::AcousticSource& source, TYTabChemin& TabChemins, double distance) const;


    /**
     * @brief Compute the spectrum of the C factor used in the diffraction calculation.
     *
     * @param epaisseur Total thickness of the obstacle.
     * @return A OSpectre giving the correction coefficient for each frequency.
     */
    OSpectre calculC(const double& epaisseur) const;

    /**
     * @brief Compute the attenuation from the diffraction on the screen.
     *
     * @param [in] rayon A segment describing the direct path between source and receptor.
     * @param [in] penteMoyenne Mean slope between source and receptor
     * @param [in] miroir Boolean to indicate if we should use the source (false) or the image source (true) during the walking difference computation
     * @param [in] re Path length to take into account for the walking difference computation
     * @param [in] epaisseur Total thickness of the obstacle.
     * @param [in] vertical Boolean to indicate we deal with the vertical plane (maximal attenuation is limited)
     * @param [in] avantApres Boolean to indicate if we are before (false) or after (true) the obstacle
     * @param [out] bDiffOk Set to false if the walking difference is <=0, true otherwise
     * @return Attenuation from the diffraction on the screen.
     */
    OSpectre calculAttDiffraction(const OSegment3D& rayon, const OSegment3D& penteMoyenne, const bool& miroir, const double& re, const double& epaisseur, const bool& vertical, const bool& avantApres, bool& bDiffOk) const;

    /**
     * @brief Limit the screen attenuation value with a frequency dependent criteria
     * @param sNC Non corrected spectrum
     * @param C
     **/
    OSpectre limAttDiffraction(const OSpectre& sNC, const OSpectre& C) const;

    /**
     * @brief Compute the different steps from a point to another via a reflection and a direct view.
     *
     * @param [in] ptDebut Starting point.
     * @param [in] ptFin Ending point.
     * @param [in] penteMoyenne Mean slope.
     * @param [in] source Acoustic source.
     * @param [in] fromSource Boolean if the starting point is the source.
     * @param [in] toRecepteur Boolean if the ending point is the receptor.
     * @param [out] Etapes Array of all the computed TYEtape steps.
     * @param [out] longueur Total length of the different steps
     *
     * @return bool <code>true</code> if succeeds;
     *              <code>false</code> if not.
     */
    bool addEtapesSol(const OPoint3D& ptDebut, const OPoint3D& ptFin, const OSegment3D& penteMoyenne, const tympan::AcousticSource& source, const bool& fromSource, const bool& toRecepteur, TYTabEtape& Etapes, double& longueur) const;

    /**
     * @brief Add a direct journey to all the paths.
     * @param [in] EtapeDirecte Direct journey.
     * @param [out] TabChemin Array of all paths.
     */
    void addEtapeDirectToChemins(const TYEtape& EtapeDirecte, TYTabChemin& TabChemin) const;

    /**
     * @brief Compute the source contribution to the point
     * @param trajet Journey
     */
    bool solve(TYTrajet& trajet);

private :
    /*!
     * \brief Find Reflexion spectrum at point defined by the end of an incident segment.
     */
    OSpectreComplex getReflexionSpectrumAt(const OSegment3D& incident, double length, const OSegment3D& segPente) const;

    /*!
     * \brief Create a segment corresponding to the projection of "director" segment on the ground
     */
    void meanSlope(const OSegment3D& director, OSegment3D& slope) const;

private:
    bool _useSol;
    bool _useReflex;
    bool _conditionFav;
    bool _useAtmo;
    bool _interference;
    double _paramH;

    std::unique_ptr<AtmosphericConditions> pSolverAtmos;

    OSpectre _lambda;
    OSpectreComplex _absoNulle;


    /// Reference to the solver
    TYSolver& _solver;
};

#endif // __TYACOUSTICMODEL__
